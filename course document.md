# 字符

## ASCII 码是什么

计算机只能存储二进制的$0$或$1$，这使得我们可以存储定点数，但是要想直接存储字符是比较困难的。

所以科学家就想到，如果我们给字符到数字进行一个一一映射，把这个字符的对应数字的二进制形式存入计算机中，在读取的时候先取得这个二进制串再转化回字符即可。

这个数字就是这个对应字符的一个***编码***。

**例**：我们设字符```'a'```对应的数字是$97$，那么我们要往计算机中存一个```'a'```就是往里面放了一个$0110 0001$这个二进制串进去。

在1963年一群美国人想要做一套现代英语的电脑编码系统，所以就发布了ASCII标准。

## ASCII 包含什么

ASCII作为一个标准，实质上就是规定了字符到数字的映射关系：

| 十进制 | 八进制 | 十六进制 | 二进制 | 符号 | 说明 |
|---|---|---|---|---|---|
0|000|00|00000000|NUL|空字符|
1|001|01|00000001|SOH|标题开始|
2|002|02|00000010|STX|正文开始|
3|003|03|00000011|ETX|正文结束|
4|004|04|00000100|EOT|传输结束|
5|005|05|00000101|ENQ|询问|
6|006|06|00000110|ACK|收到通知|
7|007|07|00000111|BEL|铃|
8|010|08|00001000|BS|退格|
9|011|09|00001001|HT|水平制表符|
10|012|0A|00001010|LF|换行键|
11|013|0B|00001011|VT|垂直制表符|
12|014|0C|00001100|FF|换页键|
13|015|0D|00001101|CR|回车键|
14|016|0E|00001110|SO|移出|
15|017|0F|00001111|SI|移入|
16|020|10|00010000|DLE|数据链路转义|
17|021|11|00010001|DC1|设备控制1|
18|022|12|00010010|DC2|设备控制2|
19|023|13|00010011|DC3|设备控制3|
20|024|14|00010100|DC4|设备控制4|
21|025|15|00010101|NAK|拒绝接收|
22|026|16|00010110|SYN|同步空闲|
23|027|17|00010111|ETB|传输块结束|
24|030|18|00011000|CAN|取消|
25|031|19|00011001|EM|介质中断|
26|032|1A|00011010|SUB|替换|
27|033|1B|00011011|ESC|换码符|
28|034|1C|00011100|FS|文件分隔符|
29|035|1D|00011101|GS|组分隔符|
30|036|1E|00011110|RS|记录分离符|
31|037|1F|00011111|US|单元分隔符|
32|040|20|00100000||空格|
33|041|21|00100001|!|感叹号|
34|042|22|00100010|"|双引号|
35|043|23|00100011|#|井号|
36|044|24|00100100|$|美元符|
37|045|25|00100101|%|百分号|
38|046|26|00100110|&|与|
39|047|27|00100111|'|单引号|
40|050|28|00101000|(|左括号|
41|051|29|00101001|)|右括号|
42|052|2A|00101010|*|星号|
43|053|2B|00101011|+|加号|
44|054|2C|00101100|,|逗号|
45|055|2D|00101101|-|连字号或减号|
46|056|2E|00101110|.|句点或小数点|
47|057|2F|00101111|/|斜杠|
48|060|30|00110000|0|0|
49|061|31|00110001|1|1|
50|062|32|00110010|2|2|
51|063|33|00110011|3|3|
52|064|34|00110100|4|4|
53|065|35|00110101|5|5|
54|066|36|00110110|6|6|
55|067|37|00110111|7|7|
56|070|38|00111000|8|8|
57|071|39|00111001|9|9|
58|072|3A|00111010|:|冒号|
59|073|3B|00111011|;|分号|
60|074|3C|00111100|<|小于|
61|075|3D|00111101|=|等号|
62|076|3E|00111110|>|大于|
63|077|3F|00111111|?|问号|
64|100|40|01000000|@|电子邮件符号|
65|101|41|01000001|A|大写字母A|
66|102|42|01000010|B|大写字母B|
67|103|43|01000011|C|大写字母C|
68|104|44|01000100|D|大写字母D|
69|105|45|01000101|E|大写字母E|
70|106|46|01000110|F|大写字母F|
71|107|47|01000111|G|大写字母G|
72|110|48|01001000|H|大写字母H|
73|111|49|01001001|I|大写字母I|
74|112|4A|01001010|J|大写字母J|
75|113|4B|01001011|K|大写字母K|
76|114|4C|01001100|L|大写字母L|
77|115|4D|01001101|M|大写字母M|
78|116|4E|01001110|N|大写字母N|
79|117|4F|01001111|O|大写字母O|
80|120|50|01010000|P|大写字母P|
81|121|51|01010001|Q|大写字母Q|
82|122|52|01010010|R|大写字母R|
83|123|53|01010011|S|大写字母S|
84|124|54|01010100|T|大写字母T|
85|125|55|01010101|U|大写字母U|
86|126|56|01010110|V|大写字母V|
87|127|57|01010111|W|大写字母W|
88|130|58|01011000|X|大写字母X|
89|131|59|01011001|Y|大写字母Y|
90|132|5A|01011010|Z|大写字母Z|
91|133|5B|01011011|[|左中括号|
92|134|5C|01011100|\\ |反斜杠|
93|135|5D|01011101|]|右中括号|
94|136|5E|01011110|^|音调符号|
95|137|5F|01011111|_|下划线|
96|140|60|01100000|`|重音符|
97|141|61|01100001|a|小写字母a|
98|142|62|01100010|b|小写字母b|
99|143|63|01100011|c|小写字母c|
100|144|64|01100100|d|小写字母d|
101|145|65|01100101|e|小写字母e|
102|146|66|01100110|f|小写字母f|
103|147|67|01100111|g|小写字母g|
104|150|68|01101000|h|小写字母h|
105|151|69|01101001|i|小写字母i|
106|152|6A|01101010|j|小写字母j|
107|153|6B|01101011|k|小写字母k|
108|154|6C|01101100|l|小写字母l|
109|155|6D|01101101|m|小写字母m|
110|156|6E|01101110|n|小写字母n|
111|157|6F|01101111|o|小写字母o|
112|160|70|01110000|p|小写字母p|
113|161|71|01110001|q|小写字母q|
114|162|72|01110010|r|小写字母r|
115|163|73|01110011|s|小写字母s|
116|164|74|01110100|t|小写字母t|
117|165|75|01110101|u|小写字母u|
118|166|76|01110110|v|小写字母v|
119|167|77|01110111|w|小写字母w|
120|170|78|01111000|x|小写字母x|
121|171|79|01111001|y|小写字母y|
122|172|7A|01111010|z|小写字母z|
123|173|7B|01111011|{|左大括号|
124|174|7C|01111100|\||垂直线|
125|175|7D|01111101|}|右大括号|
126|176|7E|01111110|~|波浪号|
127|177|7F|01111111||删除|

## ASCII 有什么用

- ASCII可以用于表示字符。
- ASCII可以用于比较字符。

## 如何在C语言中使用字符

- C语言支持用ASCII码表示字符

### 什么类型？

```char```

已知上面表中已经有了$0$ ~ $127$ 共 $128$ 个字符。那么必须至少要用$7$位二进制数才能表示。

而因为计算机内部的一些东西，应该用$1$字节也就是$8$位来表示ASCII字符。

也就是说，$1$个```char```类型变量占用$1$字节的空间。

### 如何使用```char```

与```int```, ```short```, ```long```等类型一样，```char```也表示的是一种数字，只不过它表示的数字对应了一个字符。所以```char```也可以进行```+```, ```-```, ```*```, ```/```, ```%```等等操作。

理解```char```不仅表示数字，还代表了这个数字所对应的字符后，尝试理解以下代码：
```C
#include <stdio.h>
#include <assert.h>

void code1()
{
    /*  CODE 1  */
    printf("CODE 1:\n");
    char c1 = 'A';
    int i1 = 65;
    assert(c1 == (int)c1);
    printf("as int, c1 = %d, i1 = %d\n", (int)c1, i1);
    assert(i1 == (char)i1);
    printf("as char, c1 = %c, i1 = %c\n", c1, (char)i1);
    int diff = c1 - i1;
    printf("the difference is %d\n", diff);
}

void code2()
{
    /*  CODE 2  */
    printf("CODE 2:\n");
    char c1 = 'A' * 'A';
    int i1 = 'A' * 'A';
    printf("c1 = %c\n", c1);
    printf("i1 = %d\n", i1);
}

void code3()
{
    /*  CODE 3  */
    /* Try to input "a 97", "97 97", "a a" respectively.*/
    printf("CODE 3:\n");
    char c1;
    int i1;
    scanf("%c %d", &c1, &i1);
    printf("%c %d\n", c1, i1);
}
```

# char[]字符串

> 一个 字符串 $S$ 是将 $n$ 个字符顺次排列形成的序列，$n$ 称为 $S$ 的长度，表示为 $|S|$。

## 如何实现？

因为字符串是零个或多个字符拼出来的，所以用字符数组就可以很好地表示。

它可以这样表示：
```C
char str1[500] = "string";
char str2[500] = {'A', 'B', 'C'};
```

**注意**:
```str1```这个数组有$500$个```char```不代表这个字符串有$500$个字符这么长！直观上来看，字符串```str1```的长度应该为$6$。

那么应该存在一个特殊的字符，它有且仅有这一个功能：表示这个字符串到此为止了！前辈当然也能想到这一点，所以C语言规定字符串的末尾标记符是```'\0'```。

![Error](image.png)

所以，为了给```'\0'```留出空间，```str1```数组的大小至少得是$7$。

## 常用函数

首先，这些函数都在头文件```string.h```中声明，所以我们需要先
```C
#include <string.h>
```

这里列举一些常用的字符串处理函数

1. ```strlen``` 字符串长度 length
2. ```strcmp``` 字符串比较 compare, 按照字典序，若前==后，返回0，前>后，返回大于0的值，前<后，返回小于0的值。
3. ```strcpy``` 字符串复制 copy
4. ```strcat``` 字符串拼接 concatenate

结合下方代码和链接进行食用：

[string.h Tutorial](https://www.geeksforgeeks.org/c-library-string-h/)

[string.h Document](https://en.cppreference.com/w/cpp/string/byte)

```C
void code4()
{
    /*  CODE 4  */
    printf("CODE 4:\n");
    char str[500] = "string";
    int len = strlen(str);
    printf("str = %s, len = %d\n", str, len);
    strcpy(str, "I am changed");
    printf("str = %s\n", str);
    char str2[500] = "I ma changed";
    printf("compare result of str and str2 = %d\n", strcmp(str, str2));
    printf("difference between 'a' and 'm' = %d\n", 'a' - 'm');
    strcat(str, str2);
    printf("str = %s\n", str);
}
```

## 练习

如何遍历一个字符串？

# std::string 字符串(C++)

> ```std::string```是C++标准库中提供的字符串类，它封装了许多字符串处理的函数，比上面的C风格的字符数组更加易用，并且慢不到哪里去。

它和字符数组不同的是，它的大小是可变的。

配合下方讲解和链接食用：
[std::string Document](https://en.cppreference.com/w/cpp/string/basic_string)

## 使用std::string

首先，这是C++的东西，所以得引进一些新的技术：

```C++
#include <string>
using namespace std;
```

因为竞赛讲求编写代码的速度，讲求要能Accepted而不是代码有多规范，在```using namespace std```之后，你就不用写```std::string```，直接写```string```即可。

## 创建和初始化

方式实在太多，这里只给出一些常用的：

```C++
void code1()
{
    string s1;
    string s2 = "QWERTYuiop";
    string s3(s2);
    string s4(5,'a');
}
```

## 输入输出

来点更加```C++```的输入、输出方式！

### 使用```std::cin```和```std::cout```

首先干这个事：
```C++
#include <iostream>
using namespace std;
```
先别管太多，我们先这样
- 把```cin >>```当作```scanf()```
- 把```cout <<```当作```printf()```
- 把```cin.get()```当作```getchar()```
- 把```getline()```当作```gets()```

尝试阅读以下代码：

```C++
void code2()
{
    string s1, s2;
    cin >> s1 >> s2;
    cin.get();
    string s3;
    getline(cin, s3);
    cout << "s1 = " << s1 << endl
         << "s2 = " << s2 << endl
         << "s3 = " << s3 << endl;
}
```

但是```C++```的```cin```和```cout```并不够快，我们需要从这三个方面加速：
1. 关闭同步流
2. 取消绑定
3. 不要滥用```std::endl```

具体原理参照：[输入、输出优化](https://oi-wiki.org/contest/io/)

对上述代码进行改造，得到
```C++
void code3()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string s1, s2;
    cin >> s1 >> s2;
    cin.get();
    string s3;
    getline(cin, s3);
    cout << "s1 = " << s1 << "\n"
        << "s2 = " << s2 << "\n"
        << "s3 = " << s3 << "\n";
}
```

## 常用函数

*如果你玩过```std::vector```，那么使用```std::string```易如反掌*

*如果你玩过```Python```，那么你会发现：你用```std::string```来处理ASCII字符串，舒适度比```char```数组不知道高到哪里去了*

### 获取长度

请放心，获取长度的时间复杂度是$O(1)$的
```C++
string s = "NENU";
cout << s.size() << " " << s.length() << "\n";
```
但非常令人不安的是，上面的两个函数和此前的```strlen()```函数返回值的类型都是```size_t```(```unsigned long```)，是一种无符号数，绝大多数的OJ评测机（Linux x64）上，是64位的无符号数。如果有```int```与它运算，会把这个```int```隐式转化为```unsigned long```，然后也许就会出现奇怪的事情：

```C++
string s = "NENU";
if (-1 >= s.size())
    cout << "???" << "\n";
```

同时，要知道C++的一个规定：

> 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作，可能崩溃，也可能产生垃圾数据。

下面这个代码可能很多人的机器都不会出事，但是只要是雷，总有一天会炸。

```C++
string s = "NENU";
for (int i = s.length() - 10; i >= 0; i--)
    cout << s[i] << " ";
```

### 其他实用函数

```find(str, pos)```可以查找字符串中一个字符/字符串在 ```pos```（含）之后第一次出现的位置（若不传参给 ```pos``` 则默认为 ```0```）如果没有出现，则返回 ```string::npos```（被定义为 ```-1```，但类型仍为 ```size_t```/```unsigned long```）。*和其它STL容器不同，它们通常是```xxx.end()```*

```substr(pos, len)```可以截取字符串的子字符串。也就是从```pos```开始，最多```len```个字符的字符串。

```insert(index, str)```表示在 ```index``` 处插入字符串 ```str```。

```erase(index, count)```将字符串 ```index``` 位置开始（含）的 ```count``` 个字符删除。

***例***：
```C++
void code5()
{
    string s = "aaa";
    string ss(3, 'b');
    string scat = s + ss;
    bool cmpres = s < ss;
    cout << "s + ss = " << scat << "\n";
    cout << "s is smaller then ss : " << boolalpha << cmpres << "\n";
}

void code6()
{
    string s = "abcdefg";
    cout << s.find('c') << "\n";
    cout << boolalpha << (s.find('c', 3) == string::npos) << "\n";
    s.insert(3, "hhh");
    cout << s << "\n";
    s.erase(3, 3);
    cout << s << "\n";
    reverse(s.begin(), s.end());
    cout << s << "\n";
}
```

## 练习

如何遍历一个```std::string```？

```C++
string s = "Northeast Normal University";
for (int i = 0; i < s.length(); i++)
    cout << s[i];
cout << "\n";

//For C++11 or higher
for (char ch : s)
    cout << ch;
cout << "\n";
```

## 字符串周边

### 子串(substring)
字符串 $S$ 的 子串 ，$S[i..j]，i≤j$，表示 $S$ 串中从 $i$ 到 $j$ 这一段，也就是顺次排列 $S[i],S[i+1],\ldots,S[j]$ 形成的字符串。

有时也会用 $S[i..j]，i>j$ 来表示空串。

### 子序列(subsequence)
字符串 $S$ 的 子序列 是从 $S$ 中将若干元素提取出来并不改变相对位置形成的序列，即 $S[p_1],S[p_2],\ldots,S[p_k]，1\le p_1< p_2<\cdots< p_k\le|S|$。

### 后缀(suffix)
后缀 是指从某个位置 $i$ 开始到整个串末尾结束的一个特殊子串。字符串 $S$ 的从 $i$ 开头的后缀表示为 $\textit{Suffix(S,i)}$，也就是 $\textit{Suffix(S,i)}=S[i..|S|-1]$。

真后缀 指除了 $S$ 本身的 $S$ 的后缀。

举例来说，字符串 ```abcabcd``` 的所有后缀为 ```{d, cd, bcd, abcd, cabcd, bcabcd, abcabcd}```，而它的真后缀为 ```{d, cd, bcd, abcd, cabcd, bcabcd}```。

### 前缀(prefix)
前缀 是指从串首开始到某个位置 $i$ 结束的一个特殊子串。字符串 $S$ 的以 $i$ 结尾的前缀表示为 $\textit{Prefix(S,i)}$，也就是 $\textit{Prefix(S,i)}=S[0..i]$。

真前缀 指除了 $S$ 本身的 $S$ 的前缀。

举例来说，字符串 ```abcabcd``` 的所有前缀为 ```{a, ab, abc, abca, abcab, abcabc, abcabcd}```, 而它的真前缀为 ```{a, ab, abc, abca, abcab, abcabc}```。

### 回文串(palindrome)
回文串 是正着写和倒着写相同的字符串，即满足 $\forall 1\le i\le|s|, s[i]=s[|s|+1-i]$ 的 $s$。